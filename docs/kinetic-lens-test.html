<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>KineticLens - Precision Motion Measurement</title>
    <style>
        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --bg-card: #1a1a24;
            --border: #2a2a3a;
            --text: #e0e0e0;
            --text-dim: #666;
            --accent: #00ff88;
            --accent-dim: #00aa55;
            --warning: #ffaa00;
            --error: #ff4444;
            --info: #00aaff;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }

        .app {
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            height: 100dvh;
        }

        /* Header */
        .header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent), var(--info));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .logo-text {
            font-weight: 600;
            font-size: 16px;
            color: var(--accent);
        }

        .status-bar {
            display: flex;
            gap: 12px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: var(--text-dim);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--error);
            transition: background 0.3s;
        }

        .status-dot.active { background: var(--accent); }
        .status-dot.pending { background: var(--warning); animation: pulse 1s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Main content */
        .main {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 0;
            overflow: hidden;
        }

        @media (max-width: 900px) {
            .main {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto;
            }
            .sidebar {
                max-height: 40vh;
                overflow-y: auto;
            }
        }

        /* Video Area */
        .video-area {
            position: relative;
            background: #000;
            overflow: hidden;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #moireOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            mix-blend-mode: difference;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #moireOverlay.active { opacity: 0.3; }

        .video-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-dim);
        }

        .video-placeholder h2 {
            font-size: 18px;
            margin-bottom: 8px;
            color: var(--text);
        }

        .video-placeholder p {
            font-size: 13px;
            margin-bottom: 16px;
        }

        .video-placeholder.error { color: var(--error); }
        .video-placeholder.error h2 { color: var(--error); }

        /* HUD Overlays */
        .hud-speed {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px 24px;
            min-width: 140px;
        }

        .hud-speed .value {
            font-size: 48px;
            font-weight: 200;
            color: var(--accent);
            line-height: 1;
        }

        .hud-speed .unit {
            font-size: 14px;
            color: var(--text-dim);
            margin-left: 4px;
        }

        .hud-speed .secondary {
            font-size: 18px;
            color: var(--text-dim);
            margin-top: 4px;
        }

        .hud-compass {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
        }

        .hud-orientation {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            font-size: 12px;
        }

        .hud-orientation .row {
            display: flex;
            justify-content: space-between;
            gap: 16px;
            margin: 4px 0;
        }

        .hud-orientation .label { color: var(--text-dim); }
        .hud-orientation .val { color: var(--accent); font-weight: 500; }

        .hud-vertex {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 8px 14px;
            font-size: 14px;
            font-weight: 600;
            color: var(--accent);
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .panel-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
            margin-bottom: 12px;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .metric-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 12px;
        }

        .metric-card.full { grid-column: 1 / -1; }

        .metric-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 300;
            color: var(--text);
        }

        .metric-value.accent { color: var(--accent); }
        .metric-value.small { font-size: 16px; }

        .metric-unit {
            font-size: 12px;
            color: var(--text-dim);
            margin-left: 2px;
        }

        /* 24-Cell Display */
        .cell-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }

        .cell {
            aspect-ratio: 1;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: var(--text-dim);
            transition: all 0.15s;
        }

        .cell.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg-dark);
            font-weight: 600;
            transform: scale(1.1);
            box-shadow: 0 0 12px var(--accent);
        }

        /* Graph */
        .graph-container {
            height: 80px;
            background: var(--bg-card);
            border-radius: 8px;
            overflow: hidden;
        }

        /* Progress bars */
        .progress-bar {
            height: 6px;
            background: var(--bg-card);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.2s;
            border-radius: 3px;
        }

        .progress-fill.warning { background: var(--warning); }
        .progress-fill.error { background: var(--error); }

        /* Controls */
        .controls {
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            padding: 12px 16px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            background: var(--bg-card);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 10px 20px;
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--border);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn.primary {
            background: var(--accent);
            color: var(--bg-dark);
            border-color: var(--accent);
        }

        .btn.primary:hover {
            background: var(--accent-dim);
        }

        .btn.active {
            background: var(--accent);
            color: var(--bg-dark);
        }

        .btn-icon {
            font-size: 16px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .control-label {
            font-size: 12px;
            color: var(--text-dim);
        }

        .control-input {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 13px;
            width: 80px;
        }

        .control-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .toggle {
            display: flex;
            gap: 2px;
            background: var(--bg-card);
            border-radius: 6px;
            padding: 2px;
        }

        .toggle-btn {
            padding: 6px 12px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toggle-btn.active {
            background: var(--accent);
            color: var(--bg-dark);
        }

        /* Error modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal.show { display: flex; }

        .modal-content {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            text-align: center;
        }

        .modal-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .modal-text {
            color: var(--text-dim);
            margin-bottom: 24px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="logo">
                <div class="logo-icon">üìê</div>
                <span class="logo-text">KineticLens</span>
            </div>
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-dot" id="cameraStatus"></div>
                    <span>Camera</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="imuStatus"></div>
                    <span>IMU</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="flowStatus"></div>
                    <span>Flow</span>
                </div>
            </div>
        </header>

        <main class="main">
            <div class="video-area">
                <video id="video" autoplay playsinline muted></video>
                <canvas id="moireOverlay"></canvas>
                <canvas id="overlay"></canvas>

                <div class="video-placeholder" id="placeholder">
                    <h2>KineticLens Ready</h2>
                    <p>Tap Start to begin motion measurement</p>
                    <p style="font-size: 11px; color: var(--text-dim);">Uses camera + device sensors for precise tracking</p>
                </div>

                <div class="hud-speed" id="hudSpeed" style="display: none;">
                    <div><span class="value" id="speedDisplay">0.0</span><span class="unit">m/s</span></div>
                    <div class="secondary"><span id="speedKmh">0.0</span> km/h</div>
                </div>

                <div class="hud-orientation" id="hudOrientation" style="display: none;">
                    <div class="row"><span class="label">Roll</span><span class="val" id="rollDisplay">0¬∞</span></div>
                    <div class="row"><span class="label">Pitch</span><span class="val" id="pitchDisplay">0¬∞</span></div>
                    <div class="row"><span class="label">Yaw</span><span class="val" id="yawDisplay">0¬∞</span></div>
                </div>

                <div class="hud-vertex" id="hudVertex" style="display: none;">
                    <span id="vertexLabel">1</span>
                </div>

                <canvas class="hud-compass" id="compass" width="100" height="100" style="display: none;"></canvas>
            </div>

            <aside class="sidebar">
                <div class="panel">
                    <div class="panel-title">Motion</div>
                    <div class="metric-grid">
                        <div class="metric-card">
                            <div class="metric-label">Speed</div>
                            <div class="metric-value accent" id="metricSpeed">0.00<span class="metric-unit">m/s</span></div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">Direction</div>
                            <div class="metric-value" id="metricDirection">0<span class="metric-unit">¬∞</span></div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">Flow X</div>
                            <div class="metric-value small" id="metricFlowX">0.0<span class="metric-unit">px</span></div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">Flow Y</div>
                            <div class="metric-value small" id="metricFlowY">0.0<span class="metric-unit">px</span></div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Rotation</div>
                    <div class="metric-grid">
                        <div class="metric-card">
                            <div class="metric-label">Angular Rate</div>
                            <div class="metric-value" id="metricOmega">0.0<span class="metric-unit">¬∞/s</span></div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">Stability</div>
                            <div class="metric-value" id="metricStability">100<span class="metric-unit">%</span></div>
                            <div class="progress-bar">
                                <div class="progress-fill" id="stabilityBar" style="width: 100%"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">24-Cell Orientation (Hurwitz Lattice)</div>
                    <div class="cell-grid" id="cellGrid"></div>
                    <div style="margin-top: 12px; font-size: 11px; color: var(--text-dim);">
                        Vertex: <span id="vertexName" style="color: var(--accent);">1</span>
                        <span style="float: right;">Index: <span id="vertexIndex">0</span></span>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Speed History</div>
                    <div class="graph-container">
                        <canvas id="graphCanvas" width="288" height="80"></canvas>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Confidence</div>
                    <div class="metric-grid">
                        <div class="metric-card full">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="metric-label">Overall Quality</span>
                                <span class="metric-value small" id="metricConfidence">0%</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" id="confidenceBar" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>
        </main>

        <footer class="controls">
            <button class="btn primary" id="startBtn">
                <span class="btn-icon">‚ñ∂</span>
                <span>Start</span>
            </button>
            <button class="btn" id="sensorBtn">
                <span class="btn-icon">üì±</span>
                <span>Sensors</span>
            </button>
            <button class="btn" id="resetBtn">
                <span class="btn-icon">‚Ü∫</span>
                <span>Reset</span>
            </button>

            <div class="toggle" id="moireToggle">
                <button class="toggle-btn" data-value="off">Moir√© Off</button>
                <button class="toggle-btn active" data-value="on">On</button>
            </div>

            <div class="control-group">
                <span class="control-label">Distance</span>
                <input type="number" class="control-input" id="distanceInput" value="2.0" min="0.1" max="100" step="0.1">
                <span class="control-label">m</span>
            </div>
        </footer>
    </div>

    <div class="modal" id="errorModal">
        <div class="modal-content">
            <div class="modal-icon">‚ö†Ô∏è</div>
            <h3 class="modal-title" id="errorTitle">Error</h3>
            <p class="modal-text" id="errorText">Something went wrong.</p>
            <button class="btn primary" onclick="document.getElementById('errorModal').classList.remove('show')">OK</button>
        </div>
    </div>

    <script>
    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const HURWITZ = (() => {
        const q = [];
        // Unit quaternions
        q.push([1,0,0,0], [-1,0,0,0], [0,1,0,0], [0,-1,0,0],
               [0,0,1,0], [0,0,-1,0], [0,0,0,1], [0,0,0,-1]);
        // Half-integer quaternions
        const h = 0.5;
        for (let w = -1; w <= 1; w += 2)
            for (let x = -1; x <= 1; x += 2)
                for (let y = -1; y <= 1; y += 2)
                    for (let z = -1; z <= 1; z += 2)
                        q.push([w*h, x*h, y*h, z*h]);
        return q;
    })();

    const VERTEX_LABELS = ['1', '-1', 'i', '-i', 'j', '-j', 'k', '-k',
        '¬Ω(++++)', '¬Ω(+++-)', '¬Ω(++-+)', '¬Ω(++--)',
        '¬Ω(+-++)', '¬Ω(+-+-)', '¬Ω(+--+)', '¬Ω(+---)',
        '¬Ω(-+++)', '¬Ω(-++-)', '¬Ω(-+-+)', '¬Ω(-+--)',
        '¬Ω(--++)', '¬Ω(--+-)', '¬Ω(---+)', '¬Ω(----)'];

    // =========================================================================
    // STATE
    // =========================================================================

    const state = {
        running: false,
        camera: false,
        sensors: false,
        moireEnabled: true,

        gyro: { x: 0, y: 0, z: 0 },
        accel: { x: 0, y: 0, z: 0 },

        orientation: [1, 0, 0, 0],
        nearestVertex: 0,

        flow: { x: 0, y: 0 },
        velocity: { x: 0, y: 0 },
        speed: 0,
        speedHistory: new Array(60).fill(0),

        prevGray: null,
        lastTime: 0
    };

    // =========================================================================
    // DOM
    // =========================================================================

    const $ = id => document.getElementById(id);
    const video = $('video');
    const overlay = $('overlay');
    const ctx = overlay.getContext('2d');
    const moireCanvas = $('moireOverlay');
    const moireCtx = moireCanvas.getContext('2d');
    const compass = $('compass');
    const compassCtx = compass.getContext('2d');
    const graph = $('graphCanvas');
    const graphCtx = graph.getContext('2d');

    // Init 24-cell grid
    const cellGrid = $('cellGrid');
    for (let i = 0; i < 24; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.textContent = i;
        cell.id = `cell${i}`;
        cellGrid.appendChild(cell);
    }

    // =========================================================================
    // QUATERNION MATH
    // =========================================================================

    const quat = {
        mult: (a, b) => [
            a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3],
            a[0]*b[1] + a[1]*b[0] + a[2]*b[3] - a[3]*b[2],
            a[0]*b[2] - a[1]*b[3] + a[2]*b[0] + a[3]*b[1],
            a[0]*b[3] + a[1]*b[2] - a[2]*b[1] + a[3]*b[0]
        ],
        norm: q => {
            const m = Math.sqrt(q[0]**2 + q[1]**2 + q[2]**2 + q[3]**2);
            return m > 1e-6 ? [q[0]/m, q[1]/m, q[2]/m, q[3]/m] : [1, 0, 0, 0];
        },
        fromAxisAngle: (ax, ay, az, angle) => {
            const m = Math.sqrt(ax**2 + ay**2 + az**2);
            if (m < 1e-6) return [1, 0, 0, 0];
            const ha = angle / 2, s = Math.sin(ha) / m;
            return [Math.cos(ha), ax * s, ay * s, az * s];
        },
        dist: (a, b) => {
            let d = Math.abs(a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3]);
            return 2 * Math.acos(Math.min(1, d));
        },
        toEuler: q => {
            const [w, x, y, z] = q;
            const sinp = 2 * (w * y - z * x);
            let pitch, roll, yaw;
            if (Math.abs(sinp) >= 0.999) {
                pitch = Math.sign(sinp) * Math.PI / 2;
                roll = 0;
                yaw = 2 * Math.atan2(z, w);
            } else {
                pitch = Math.asin(sinp);
                roll = Math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y));
                yaw = Math.atan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z));
            }
            return { roll: roll * 57.2958, pitch: pitch * 57.2958, yaw: yaw * 57.2958 };
        }
    };

    function findNearestVertex(q) {
        let best = 0, bestDist = Infinity;
        for (let i = 0; i < 24; i++) {
            const d = quat.dist(q, HURWITZ[i]);
            if (d < bestDist) { bestDist = d; best = i; }
        }
        return best;
    }

    // =========================================================================
    // IMU
    // =========================================================================

    const imu = {
        orientation: [1, 0, 0, 0],
        bias: [0, 0, 0],

        update(gyro, accel, dt) {
            if (dt <= 0 || dt > 0.5) return;

            const gx = gyro.x - this.bias[0];
            const gy = gyro.y - this.bias[1];
            const gz = gyro.z - this.bias[2];

            const angle = Math.sqrt(gx**2 + gy**2 + gz**2) * dt;
            if (angle > 1e-5) {
                const delta = quat.fromAxisAngle(gx, gy, gz, angle);
                this.orientation = quat.norm(quat.mult(this.orientation, delta));
            }

            // Bias learning when stationary
            const am = Math.sqrt(accel.x**2 + accel.y**2 + accel.z**2);
            const gm = Math.sqrt(gyro.x**2 + gyro.y**2 + gyro.z**2);
            if (am > 9 && am < 11 && gm < 0.1) {
                this.bias[0] += 0.001 * gyro.x;
                this.bias[1] += 0.001 * gyro.y;
                this.bias[2] += 0.001 * gyro.z;
            }
        },

        reset() {
            this.orientation = [1, 0, 0, 0];
            this.bias = [0, 0, 0];
        }
    };

    // =========================================================================
    // OPTICAL FLOW
    // =========================================================================

    function computeFlow(imageData) {
        const w = imageData.width, h = imageData.height;
        const gray = new Uint8Array(w * h);
        const d = imageData.data;

        for (let i = 0; i < gray.length; i++) {
            const j = i * 4;
            gray[i] = (d[j] * 77 + d[j+1] * 150 + d[j+2] * 29) >> 8;
        }

        if (!state.prevGray) {
            state.prevGray = gray;
            return null;
        }

        let totalDx = 0, totalDy = 0, count = 0;
        const gs = 32, sr = 16;

        for (let gy = sr + 8; gy < h - sr - 8; gy += gs) {
            for (let gx = sr + 8; gx < w - sr - 8; gx += gs) {
                let bestDx = 0, bestDy = 0, bestSAD = Infinity;

                for (let dy = -sr; dy <= sr; dy += 4) {
                    for (let dx = -sr; dx <= sr; dx += 4) {
                        let sad = 0;
                        for (let by = -4; by < 4; by += 2) {
                            for (let bx = -4; bx < 4; bx += 2) {
                                const i1 = (gy + by) * w + (gx + bx);
                                const i2 = (gy + by + dy) * w + (gx + bx + dx);
                                sad += Math.abs(gray[i1] - state.prevGray[i2]);
                            }
                        }
                        if (sad < bestSAD) { bestSAD = sad; bestDx = dx; bestDy = dy; }
                    }
                }

                if (bestSAD < 3000) {
                    totalDx += bestDx;
                    totalDy += bestDy;
                    count++;
                }
            }
        }

        state.prevGray = gray;
        return count > 0 ? { x: totalDx / count, y: totalDy / count } : { x: 0, y: 0 };
    }

    // =========================================================================
    // MOIR√â GENERATOR
    // =========================================================================

    function drawMoire(width, height, rotation, phase) {
        moireCanvas.width = width;
        moireCanvas.height = height;

        const img = moireCtx.createImageData(width, height);
        const d = img.data;
        const freq = 0.15;
        const cos = Math.cos(rotation), sin = Math.sin(rotation);

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const xr = (x - width/2) * cos - (y - height/2) * sin;
                const v = Math.sin(xr * freq + phase) > 0 ? 255 : 0;
                const i = (y * width + x) * 4;
                d[i] = d[i+1] = d[i+2] = v;
                d[i+3] = 255;
            }
        }
        moireCtx.putImageData(img, 0, 0);
    }

    // =========================================================================
    // DRAWING
    // =========================================================================

    function drawOverlay(width, height) {
        ctx.clearRect(0, 0, width, height);
        const cx = width / 2, cy = height / 2;

        // Flow vector
        const scale = 8;
        const fx = state.flow.x * scale, fy = state.flow.y * scale;
        const mag = Math.sqrt(fx**2 + fy**2);

        if (mag > 2) {
            ctx.strokeStyle = `rgba(0, 255, 136, ${Math.min(1, mag / 50)})`;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + fx, cy + fy);
            ctx.stroke();

            // Arrow
            const angle = Math.atan2(fy, fx);
            ctx.beginPath();
            ctx.moveTo(cx + fx, cy + fy);
            ctx.lineTo(cx + fx - 12 * Math.cos(angle - 0.4), cy + fy - 12 * Math.sin(angle - 0.4));
            ctx.moveTo(cx + fx, cy + fy);
            ctx.lineTo(cx + fx - 12 * Math.cos(angle + 0.4), cy + fy - 12 * Math.sin(angle + 0.4));
            ctx.stroke();
        }

        // Crosshair
        ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(cx - 40, cy); ctx.lineTo(cx + 40, cy);
        ctx.moveTo(cx, cy - 40); ctx.lineTo(cx, cy + 40);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function drawCompass() {
        const w = compass.width, h = compass.height;
        const cx = w / 2, cy = h / 2, r = 40;

        compassCtx.clearRect(0, 0, w, h);

        // Ring
        compassCtx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
        compassCtx.lineWidth = 2;
        compassCtx.beginPath();
        compassCtx.arc(cx, cy, r, 0, Math.PI * 2);
        compassCtx.stroke();

        // Direction
        const dir = Math.atan2(state.velocity.y, state.velocity.x);
        const mag = Math.sqrt(state.velocity.x**2 + state.velocity.y**2);

        if (mag > 0.01) {
            compassCtx.strokeStyle = '#00ff88';
            compassCtx.lineWidth = 3;
            compassCtx.beginPath();
            compassCtx.moveTo(cx, cy);
            compassCtx.lineTo(cx + r * 0.8 * Math.cos(dir), cy + r * 0.8 * Math.sin(dir));
            compassCtx.stroke();
        }

        // N marker
        compassCtx.fillStyle = '#666';
        compassCtx.font = '10px sans-serif';
        compassCtx.textAlign = 'center';
        compassCtx.fillText('N', cx, cy - r - 5);
    }

    function drawGraph() {
        const w = graph.width, h = graph.height;
        graphCtx.fillStyle = '#1a1a24';
        graphCtx.fillRect(0, 0, w, h);

        const max = Math.max(1, ...state.speedHistory);
        const step = w / state.speedHistory.length;

        graphCtx.strokeStyle = '#00ff88';
        graphCtx.lineWidth = 2;
        graphCtx.beginPath();

        for (let i = 0; i < state.speedHistory.length; i++) {
            const x = i * step;
            const y = h - (state.speedHistory[i] / max) * (h - 10) - 5;
            if (i === 0) graphCtx.moveTo(x, y);
            else graphCtx.lineTo(x, y);
        }
        graphCtx.stroke();

        // Current value
        graphCtx.fillStyle = '#00ff88';
        graphCtx.font = '10px sans-serif';
        graphCtx.fillText(`${state.speed.toFixed(2)} m/s`, 5, 12);
    }

    // =========================================================================
    // UPDATE
    // =========================================================================

    function updateUI() {
        // HUD
        $('speedDisplay').textContent = state.speed.toFixed(1);
        $('speedKmh').textContent = (state.speed * 3.6).toFixed(1);

        const euler = quat.toEuler(state.orientation);
        $('rollDisplay').textContent = euler.roll.toFixed(0) + '¬∞';
        $('pitchDisplay').textContent = euler.pitch.toFixed(0) + '¬∞';
        $('yawDisplay').textContent = euler.yaw.toFixed(0) + '¬∞';
        $('vertexLabel').textContent = VERTEX_LABELS[state.nearestVertex];

        // Sidebar
        $('metricSpeed').innerHTML = state.speed.toFixed(2) + '<span class="metric-unit">m/s</span>';
        $('metricDirection').innerHTML = (Math.atan2(state.velocity.y, state.velocity.x) * 57.3).toFixed(0) + '<span class="metric-unit">¬∞</span>';
        $('metricFlowX').innerHTML = state.flow.x.toFixed(1) + '<span class="metric-unit">px</span>';
        $('metricFlowY').innerHTML = state.flow.y.toFixed(1) + '<span class="metric-unit">px</span>';

        const omega = Math.sqrt(state.gyro.x**2 + state.gyro.y**2 + state.gyro.z**2) * 57.3;
        $('metricOmega').innerHTML = omega.toFixed(1) + '<span class="metric-unit">¬∞/s</span>';

        const stability = Math.max(0, 100 - omega * 5);
        $('metricStability').innerHTML = stability.toFixed(0) + '<span class="metric-unit">%</span>';
        const stabBar = $('stabilityBar');
        stabBar.style.width = stability + '%';
        stabBar.className = 'progress-fill' + (stability < 30 ? ' error' : stability < 60 ? ' warning' : '');

        $('vertexName').textContent = VERTEX_LABELS[state.nearestVertex];
        $('vertexIndex').textContent = state.nearestVertex;

        // 24-cell
        document.querySelectorAll('.cell').forEach((c, i) => c.classList.toggle('active', i === state.nearestVertex));

        // Confidence
        const conf = (state.camera ? 40 : 0) + (state.sensors ? 40 : 0) + (Math.sqrt(state.flow.x**2 + state.flow.y**2) > 1 ? 20 : 0);
        $('metricConfidence').textContent = conf + '%';
        const confBar = $('confidenceBar');
        confBar.style.width = conf + '%';
        confBar.className = 'progress-fill' + (conf < 30 ? ' error' : conf < 60 ? ' warning' : '');

        drawCompass();
        drawGraph();
    }

    // =========================================================================
    // MAIN LOOP
    // =========================================================================

    function loop(timestamp) {
        if (!state.running) return;

        const dt = state.lastTime ? (timestamp - state.lastTime) / 1000 : 0;
        state.lastTime = timestamp;

        // IMU
        if (state.sensors && dt > 0) {
            imu.update(state.gyro, state.accel, dt);
            state.orientation = imu.orientation;
        }

        // 24-cell
        state.nearestVertex = findNearestVertex(state.orientation);

        // Optical flow
        if (state.camera && video.readyState >= 2) {
            const w = video.videoWidth, h = video.videoHeight;
            overlay.width = w; overlay.height = h;

            ctx.drawImage(video, 0, 0, w, h);
            const imgData = ctx.getImageData(0, 0, w, h);
            const flow = computeFlow(imgData);

            if (flow) {
                state.flow.x = state.flow.x * 0.7 + flow.x * 0.3;
                state.flow.y = state.flow.y * 0.7 + flow.y * 0.3;
                $('flowStatus').classList.add('active');
            }

            // Velocity
            const dist = parseFloat($('distanceInput').value) || 2;
            const focal = w;
            state.velocity.x = state.velocity.x * 0.9 + (state.flow.x * dist / focal) * 0.1;
            state.velocity.y = state.velocity.y * 0.9 + (state.flow.y * dist / focal) * 0.1;
            state.speed = Math.sqrt(state.velocity.x**2 + state.velocity.y**2);

            state.speedHistory.push(state.speed);
            state.speedHistory.shift();

            // Draw
            drawOverlay(w, h);

            // Moir√©
            if (state.moireEnabled) {
                const euler = quat.toEuler(state.orientation);
                drawMoire(w, h, euler.yaw * 0.0174533, state.flow.x * 0.1);
                moireCanvas.classList.add('active');
            } else {
                moireCanvas.classList.remove('active');
            }
        }

        updateUI();
        requestAnimationFrame(loop);
    }

    // =========================================================================
    // CAMERA
    // =========================================================================

    async function startCamera() {
        if (!navigator.mediaDevices?.getUserMedia) {
            showError('Camera Not Available', 'Camera API requires HTTPS. Please access this page via https:// or localhost.');
            return;
        }

        $('cameraStatus').classList.add('pending');

        try {
            let stream;
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
            } catch {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 1280 }, height: { ideal: 720 } }
                });
            }

            video.srcObject = stream;
            await new Promise((res, rej) => {
                video.onloadedmetadata = () => video.play().then(res).catch(rej);
                setTimeout(() => rej(new Error('Timeout')), 10000);
            });

            state.camera = true;
            $('cameraStatus').classList.remove('pending');
            $('cameraStatus').classList.add('active');
            $('placeholder').style.display = 'none';

            // Show HUDs
            $('hudSpeed').style.display = 'block';
            $('hudOrientation').style.display = 'block';
            $('hudVertex').style.display = 'block';
            compass.style.display = 'block';

        } catch (err) {
            $('cameraStatus').classList.remove('pending');
            let msg = err.message;
            if (err.name === 'NotAllowedError') msg = 'Camera permission denied. Please allow camera access and reload.';
            else if (err.name === 'NotFoundError') msg = 'No camera found on this device.';
            else if (location.protocol !== 'https:' && location.hostname !== 'localhost')
                msg = 'Camera requires HTTPS. Current protocol: ' + location.protocol;
            showError('Camera Error', msg);
        }
    }

    function stopCamera() {
        video.srcObject?.getTracks().forEach(t => t.stop());
        state.camera = false;
        $('cameraStatus').classList.remove('active');
    }

    // =========================================================================
    // SENSORS
    // =========================================================================

    async function requestSensors() {
        const request = async (EventType) => {
            if (typeof EventType?.requestPermission === 'function') {
                return await EventType.requestPermission() === 'granted';
            }
            return true;
        };

        try {
            await request(DeviceOrientationEvent);
            await request(DeviceMotionEvent);
        } catch {}

        window.addEventListener('devicemotion', e => {
            if (e.rotationRate) {
                state.gyro = {
                    x: (e.rotationRate.beta || 0) * 0.0174533,
                    y: (e.rotationRate.gamma || 0) * 0.0174533,
                    z: (e.rotationRate.alpha || 0) * 0.0174533
                };
            }
            if (e.accelerationIncludingGravity) {
                state.accel = {
                    x: e.accelerationIncludingGravity.x || 0,
                    y: e.accelerationIncludingGravity.y || 0,
                    z: e.accelerationIncludingGravity.z || 0
                };
            }
            if (!state.sensors) {
                state.sensors = true;
                $('imuStatus').classList.add('active');
            }
        });
    }

    // =========================================================================
    // UI
    // =========================================================================

    function showError(title, text) {
        $('errorTitle').textContent = title;
        $('errorText').textContent = text;
        $('errorModal').classList.add('show');
    }

    $('startBtn').addEventListener('click', async () => {
        if (!state.running) {
            await startCamera();
            state.running = true;
            state.lastTime = 0;
            $('startBtn').innerHTML = '<span class="btn-icon">‚èπ</span><span>Stop</span>';
            $('startBtn').classList.add('active');
            requestAnimationFrame(loop);
        } else {
            state.running = false;
            stopCamera();
            $('startBtn').innerHTML = '<span class="btn-icon">‚ñ∂</span><span>Start</span>';
            $('startBtn').classList.remove('active');
        }
    });

    $('sensorBtn').addEventListener('click', requestSensors);

    $('resetBtn').addEventListener('click', () => {
        imu.reset();
        state.prevGray = null;
        state.flow = { x: 0, y: 0 };
        state.velocity = { x: 0, y: 0 };
        state.speed = 0;
        state.speedHistory.fill(0);
    });

    $('moireToggle').addEventListener('click', e => {
        if (e.target.classList.contains('toggle-btn')) {
            $('moireToggle').querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            state.moireEnabled = e.target.dataset.value === 'on';
        }
    });

    // Auto-enable sensors on desktop
    if (!/iPhone|iPad|Android/i.test(navigator.userAgent)) {
        requestSensors();
    }
    </script>
</body>
</html>
