<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phillips Gate Quantum Simulator Demo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0f172a;
      color: #e2e8f0;
      font-family: 'Monaco', 'Menlo', monospace;
      min-height: 100vh;
      padding: 20px;
    }
    h1 {
      color: #FACC15;
      font-size: 24px;
      margin-bottom: 10px;
    }
    h2 {
      color: #22D3EE;
      font-size: 16px;
      margin: 20px 0 10px 0;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .panel {
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 15px;
    }
    .panel-title {
      color: #FACC15;
      font-size: 14px;
      margin-bottom: 10px;
      border-bottom: 1px solid #334155;
      padding-bottom: 8px;
    }
    canvas {
      display: block;
      background: #020617;
      border-radius: 4px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
    }
    button {
      background: #334155;
      color: #e2e8f0;
      border: 1px solid #475569;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
      transition: all 0.2s;
    }
    button:hover {
      background: #475569;
      border-color: #FACC15;
    }
    button.active {
      background: #FACC15;
      color: #0f172a;
      border-color: #FACC15;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 15px;
    }
    .stat {
      background: #0f172a;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }
    .stat-value {
      color: #22D3EE;
      font-size: 18px;
      font-weight: bold;
    }
    .stat-label {
      color: #94a3b8;
      font-size: 10px;
      margin-top: 4px;
    }
    .log {
      background: #0f172a;
      padding: 10px;
      border-radius: 4px;
      height: 150px;
      overflow-y: auto;
      font-size: 11px;
      line-height: 1.5;
    }
    .log-entry {
      color: #94a3b8;
    }
    .log-entry.gate {
      color: #22D3EE;
    }
    .log-entry.measure {
      color: #F43F5E;
    }
    .log-entry.info {
      color: #FACC15;
    }
    .qubit-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 5px;
      margin-top: 10px;
    }
    .qubit-cell {
      aspect-ratio: 1;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
    }
    .legend {
      display: flex;
      gap: 20px;
      margin-top: 10px;
      font-size: 11px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>⚛️ PHILLIPS GATE QUANTUM SIMULATOR</h1>
    <p style="color: #94a3b8; margin-bottom: 20px;">
      Visual Analog Quantum Computing on 24-Cell Polytope Substrate
    </p>

    <div class="grid">
      <!-- Main Visualization Panel -->
      <div class="panel" style="grid-column: span 2;">
        <div class="panel-title">24-CELL QUANTUM SUBSTRATE (Hopf Projection)</div>
        <canvas id="mainCanvas" width="800" height="500"></canvas>
        <div class="controls">
          <button onclick="applyGate('H')">Hadamard (H)</button>
          <button onclick="applyGate('X')">Pauli-X</button>
          <button onclick="applyGate('Y')">Pauli-Y</button>
          <button onclick="applyGate('Z')">Pauli-Z</button>
          <button onclick="applyGate('T')">T-Gate</button>
          <button onclick="applyGate('S')">S-Gate</button>
          <button onclick="measureAll()">Measure All</button>
          <button onclick="resetState()">Reset</button>
          <button onclick="runGrover()">Run Grover's</button>
          <button onclick="runAnnealing()">Run Annealing</button>
        </div>
        <div class="stats">
          <div class="stat">
            <div class="stat-value" id="statTime">0</div>
            <div class="stat-label">TIME STEP</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="statEnergy">0.000</div>
            <div class="stat-label">SYSTEM ENERGY</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="statTemp">1.000</div>
            <div class="stat-label">TEMPERATURE</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="statEntangled">0</div>
            <div class="stat-label">ENTANGLED PAIRS</div>
          </div>
        </div>
      </div>

      <!-- Moiré Visualization -->
      <div class="panel">
        <div class="panel-title">MOIRÉ QUATERNION DISPLAY</div>
        <canvas id="moireCanvas" width="380" height="300"></canvas>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: #FACC15;"></div>
            <span>Reference</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #22D3EE;"></div>
            <span>Current</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #F43F5E;"></div>
            <span>Difference</span>
          </div>
        </div>
      </div>

      <!-- Nomogram -->
      <div class="panel">
        <div class="panel-title">VELOCITY NOMOGRAM (Analog Calculator)</div>
        <canvas id="nomogramCanvas" width="380" height="300"></canvas>
        <p style="font-size: 10px; color: #94a3b8; margin-top: 10px;">
          The gold line connects TIME and ENERGY. Read VELOCITY at the center scale intersection.
        </p>
      </div>

      <!-- Qubit State Grid -->
      <div class="panel">
        <div class="panel-title">QUBIT STATE REGISTER (24 Vertices)</div>
        <div class="qubit-grid" id="qubitGrid"></div>
        <div class="legend" style="margin-top: 15px;">
          <div class="legend-item">
            <div class="legend-color" style="background: #3b82f6;"></div>
            <span>|0⟩ (Blue)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #ef4444;"></div>
            <span>|1⟩ (Red)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #a855f7;"></div>
            <span>Superposition</span>
          </div>
        </div>
      </div>

      <!-- Event Log -->
      <div class="panel">
        <div class="panel-title">QUANTUM CIRCUIT LOG</div>
        <div class="log" id="eventLog"></div>
      </div>
    </div>
  </div>

  <script>
    // ═══════════════════════════════════════════════════════════════════════════
    // CONSTANTS
    // ═══════════════════════════════════════════════════════════════════════════
    const PHI = (1 + Math.sqrt(5)) / 2;
    const PHI_INV = PHI - 1;

    // ═══════════════════════════════════════════════════════════════════════════
    // GEOMETRIC ALGEBRA - ROTORS
    // ═══════════════════════════════════════════════════════════════════════════
    const ROTOR_IDENTITY = { s: 1, e12: 0, e23: 0, e31: 0 };

    function rotorFromAxisAngle(ax, ay, az, angle) {
      const mag = Math.sqrt(ax*ax + ay*ay + az*az);
      if (mag < 1e-10) return {...ROTOR_IDENTITY};
      const nx = ax/mag, ny = ay/mag, nz = az/mag;
      const c = Math.cos(angle/2), s = Math.sin(angle/2);
      return { s: c, e12: -s*nz, e23: -s*nx, e31: -s*ny };
    }

    function multiplyRotors(r1, r2) {
      return {
        s: r1.s*r2.s - r1.e12*r2.e12 - r1.e23*r2.e23 - r1.e31*r2.e31,
        e12: r1.s*r2.e12 + r1.e12*r2.s + r1.e23*r2.e31 - r1.e31*r2.e23,
        e23: r1.s*r2.e23 - r1.e12*r2.e31 + r1.e23*r2.s + r1.e31*r2.e12,
        e31: r1.s*r2.e31 + r1.e12*r2.e23 - r1.e23*r2.e12 + r1.e31*r2.s
      };
    }

    function reverseRotor(r) {
      return { s: r.s, e12: -r.e12, e23: -r.e23, e31: -r.e31 };
    }

    function normalizeRotor(r) {
      const mag = Math.sqrt(r.s*r.s + r.e12*r.e12 + r.e23*r.e23 + r.e31*r.e31);
      return { s: r.s/mag, e12: r.e12/mag, e23: r.e23/mag, e31: r.e31/mag };
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // SPINOR OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════════
    function spinorFromBloch(theta, phi) {
      const ch = Math.cos(theta/2), sh = Math.sin(theta/2);
      return { real0: ch, imag0: 0, real1: sh*Math.cos(phi), imag1: sh*Math.sin(phi) };
    }

    function spinorToBloch(s) {
      const m0 = Math.sqrt(s.real0*s.real0 + s.imag0*s.imag0);
      const m1 = Math.sqrt(s.real1*s.real1 + s.imag1*s.imag1);
      const theta = 2 * Math.atan2(m1, m0);
      const phi = Math.atan2(s.imag1, s.real1) - Math.atan2(s.imag0, s.real0);
      return { theta, phi };
    }

    function applyRotorToSpinor(r, s) {
      const ar = r.s, ai = r.e12, br = r.e31, bi = r.e23;
      return {
        real0: ar*s.real0 - ai*s.imag0 - br*s.real1 - bi*s.imag1,
        imag0: ar*s.imag0 + ai*s.real0 - br*s.imag1 + bi*s.real1,
        real1: br*s.real0 - bi*s.imag0 + ar*s.real1 + ai*s.imag1,
        imag1: br*s.imag0 + bi*s.real0 + ar*s.imag1 - ai*s.real1
      };
    }

    function normalizeSpinor(s) {
      const mag = Math.sqrt(s.real0*s.real0 + s.imag0*s.imag0 + s.real1*s.real1 + s.imag1*s.imag1);
      return { real0: s.real0/mag, imag0: s.imag0/mag, real1: s.real1/mag, imag1: s.imag1/mag };
    }

    function spinorProbs(s) {
      const p0 = s.real0*s.real0 + s.imag0*s.imag0;
      const p1 = s.real1*s.real1 + s.imag1*s.imag1;
      return { p0, p1 };
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // 24-CELL VERTICES (Hurwitz Quaternion Units)
    // ═══════════════════════════════════════════════════════════════════════════
    function get24CellVertices() {
      const verts = [];
      // 8 axis-aligned
      verts.push({x:0,y:0,z:0,w:1}, {x:0,y:0,z:0,w:-1});
      verts.push({x:1,y:0,z:0,w:0}, {x:-1,y:0,z:0,w:0});
      verts.push({x:0,y:1,z:0,w:0}, {x:0,y:-1,z:0,w:0});
      verts.push({x:0,y:0,z:1,w:0}, {x:0,y:0,z:-1,w:0});
      // 16 Hurwitz units
      const h = 0.5;
      for (let sw of [-h, h]) {
        for (let sx of [-h, h]) {
          for (let sy of [-h, h]) {
            for (let sz of [-h, h]) {
              verts.push({x: sx, y: sy, z: sz, w: sw});
            }
          }
        }
      }
      return verts;
    }

    function get24CellEdges(verts) {
      const edges = [];
      for (let i = 0; i < verts.length; i++) {
        for (let j = i + 1; j < verts.length; j++) {
          const dx = verts[i].x - verts[j].x;
          const dy = verts[i].y - verts[j].y;
          const dz = verts[i].z - verts[j].z;
          const dw = verts[i].w - verts[j].w;
          const dist = Math.sqrt(dx*dx + dy*dy + dz*dz + dw*dw);
          if (Math.abs(dist - 1) < 0.01) edges.push([i, j]);
        }
      }
      return edges;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // 4D ROTATION (Bi-Rotor)
    // ═══════════════════════════════════════════════════════════════════════════
    function applyBiRotor(L, R, x, y, z, w) {
      const Rr = reverseRotor(R);
      // L * q
      const lw = L.s*w - L.e23*x - L.e31*y - L.e12*z;
      const lx = L.s*x + L.e23*w + L.e31*z - L.e12*y;
      const ly = L.s*y - L.e23*z + L.e31*w + L.e12*x;
      const lz = L.s*z + L.e23*y - L.e31*x + L.e12*w;
      // (L*q) * R̃
      return {
        x: lw*Rr.e23 + lx*Rr.s - ly*Rr.e12 + lz*Rr.e31,
        y: lw*Rr.e31 + lx*Rr.e12 + ly*Rr.s - lz*Rr.e23,
        z: lw*Rr.e12 - lx*Rr.e31 + ly*Rr.e23 + lz*Rr.s,
        w: lw*Rr.s - lx*Rr.e23 - ly*Rr.e31 - lz*Rr.e12
      };
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // HOPF FIBRATION PROJECTION
    // ═══════════════════════════════════════════════════════════════════════════
    function hopfProject(x, y, z, w) {
      const bx = 2 * (x*z + y*w);
      const by = 2 * (y*z - x*w);
      const bz = x*x + y*y - z*z - w*w;
      const mag = Math.sqrt(bx*bx + by*by + bz*bz);
      return mag > 1e-10 ? { x: bx/mag, y: by/mag, z: bz/mag } : { x: 0, y: 0, z: 1 };
    }

    function stereographic(bx, by, bz) {
      const d = 1 - bz;
      return d > 0.01 ? { x: bx/d, y: by/d } : { x: bx*100, y: by*100 };
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // QUANTUM GATES
    // ═══════════════════════════════════════════════════════════════════════════
    const GATES = {
      I: rotorFromAxisAngle(0, 0, 1, 0),
      X: rotorFromAxisAngle(1, 0, 0, Math.PI),
      Y: rotorFromAxisAngle(0, 1, 0, Math.PI),
      Z: rotorFromAxisAngle(0, 0, 1, Math.PI),
      H: rotorFromAxisAngle(Math.SQRT1_2, 0, Math.SQRT1_2, Math.PI),
      S: rotorFromAxisAngle(0, 0, 1, Math.PI/2),
      T: rotorFromAxisAngle(0, 0, 1, Math.PI/4)
    };

    // ═══════════════════════════════════════════════════════════════════════════
    // SIMULATOR STATE
    // ═══════════════════════════════════════════════════════════════════════════
    let state = {
      qubits: [],
      globalRotor: { left: {...ROTOR_IDENTITY}, right: {...ROTOR_IDENTITY} },
      time: 0,
      energy: 0,
      temperature: 1.0,
      vertices: [],
      edges: [],
      animationAngle: 0
    };

    function initState() {
      state.vertices = get24CellVertices();
      state.edges = get24CellEdges(state.vertices);
      state.qubits = state.vertices.map((v, i) => ({
        index: i,
        state: spinorFromBloch(0, 0), // |0⟩
        bloch: { theta: 0, phi: 0 },
        entangled: []
      }));
      state.time = 0;
      state.energy = 0;
      state.temperature = 1.0;
      state.globalRotor = { left: {...ROTOR_IDENTITY}, right: {...ROTOR_IDENTITY} };
      log('System initialized with 24 qubits in |0⟩ state', 'info');
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════════
    let selectedQubit = 0;

    function applyGate(gateName) {
      const gate = GATES[gateName];
      if (!gate) return;

      // Apply to selected qubit or all if in superposition mode
      const targets = selectedQubit < 0 ? state.qubits.map((_, i) => i) : [selectedQubit % 24];

      targets.forEach(i => {
        state.qubits[i].state = normalizeSpinor(applyRotorToSpinor(gate, state.qubits[i].state));
        state.qubits[i].bloch = spinorToBloch(state.qubits[i].state);
      });

      state.time++;
      updateEnergy();
      log(`Applied ${gateName} gate to qubit${targets.length > 1 ? 's' : ''} ${targets.join(', ')}`, 'gate');
      render();
    }

    function measureAll() {
      let results = [];
      state.qubits.forEach((q, i) => {
        const { p0, p1 } = spinorProbs(q.state);
        const result = Math.random() < p0 ? 0 : 1;
        q.state = result === 0
          ? { real0: 1, imag0: 0, real1: 0, imag1: 0 }
          : { real0: 0, imag0: 0, real1: 1, imag1: 0 };
        q.bloch = result === 0 ? { theta: 0, phi: 0 } : { theta: Math.PI, phi: 0 };
        results.push(result);
      });
      state.time++;
      const ones = results.filter(r => r === 1).length;
      log(`Measured all qubits: ${ones} in |1⟩, ${24-ones} in |0⟩`, 'measure');
      render();
    }

    function resetState() {
      initState();
      render();
    }

    function updateEnergy() {
      // Simple energy: count qubits in |1⟩ state probability
      state.energy = state.qubits.reduce((sum, q) => {
        const { p1 } = spinorProbs(q.state);
        return sum + p1;
      }, 0) / 24;
    }

    function runGrover() {
      log('Starting Grover\'s Search (marking qubit 7)', 'info');

      // Initialize superposition
      state.qubits.forEach((q, i) => {
        q.state = normalizeSpinor(applyRotorToSpinor(GATES.H, spinorFromBloch(0, 0)));
        q.bloch = spinorToBloch(q.state);
      });
      state.time++;
      log('Applied Hadamard to all qubits (superposition)', 'gate');
      render();

      // Grover iterations
      setTimeout(() => {
        // Oracle: flip phase of marked state (qubit 7)
        state.qubits[7].state = normalizeSpinor(applyRotorToSpinor(GATES.Z, state.qubits[7].state));
        state.qubits[7].bloch = spinorToBloch(state.qubits[7].state);
        state.time++;
        log('Oracle: Marked qubit 7 with Z gate', 'gate');
        render();

        setTimeout(() => {
          // Diffusion operator (simplified)
          state.qubits.forEach((q, i) => {
            q.state = normalizeSpinor(applyRotorToSpinor(GATES.H, q.state));
            q.state = normalizeSpinor(applyRotorToSpinor(GATES.X, q.state));
          });
          state.time++;
          log('Applied diffusion operator', 'gate');
          render();

          setTimeout(() => {
            measureAll();
          }, 500);
        }, 500);
      }, 500);
    }

    function runAnnealing() {
      log('Starting Simulated Annealing (1000 steps)', 'info');

      // Initialize random superpositions
      state.qubits.forEach(q => {
        q.state = normalizeSpinor(applyRotorToSpinor(GATES.H, spinorFromBloch(0, 0)));
        q.bloch = spinorToBloch(q.state);
      });
      state.temperature = 10.0;
      render();

      let step = 0;
      const interval = setInterval(() => {
        // Random perturbation
        const qi = Math.floor(Math.random() * 24);
        const angle = (Math.random() - 0.5) * Math.PI * 0.1;
        const axis = Math.floor(Math.random() * 3);
        const axes = [[1,0,0], [0,1,0], [0,0,1]];
        const rotor = rotorFromAxisAngle(...axes[axis], angle);

        const oldEnergy = state.energy;
        const oldState = {...state.qubits[qi].state};

        state.qubits[qi].state = normalizeSpinor(applyRotorToSpinor(rotor, state.qubits[qi].state));
        state.qubits[qi].bloch = spinorToBloch(state.qubits[qi].state);
        updateEnergy();

        const dE = state.energy - oldEnergy;
        const accept = dE < 0 || Math.random() < Math.exp(-dE / state.temperature);

        if (!accept) {
          state.qubits[qi].state = oldState;
          state.qubits[qi].bloch = spinorToBloch(oldState);
          updateEnergy();
        }

        state.temperature *= 0.995;
        state.time++;
        step++;

        if (step % 100 === 0) {
          log(`Annealing step ${step}: T=${state.temperature.toFixed(3)}, E=${state.energy.toFixed(3)}`, 'info');
          render();
        }

        if (step >= 1000) {
          clearInterval(interval);
          log('Annealing complete!', 'info');
          render();
        }
      }, 10);
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // RENDERING
    // ═══════════════════════════════════════════════════════════════════════════
    function render() {
      renderMain();
      renderMoire();
      renderNomogram();
      renderQubitGrid();
      updateStats();
    }

    function renderMain() {
      const canvas = document.getElementById('mainCanvas');
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;

      ctx.fillStyle = '#020617';
      ctx.fillRect(0, 0, W, H);

      const cx = W / 2, cy = H / 2;
      const scale = 150;

      // Animate rotation
      state.animationAngle += 0.005;
      const animRotor = rotorFromAxisAngle(0.3, 1, 0.5, state.animationAngle);

      // Project vertices
      const projected = state.vertices.map(v => {
        const rot = applyBiRotor(animRotor, animRotor, v.x, v.y, v.z, v.w);
        const hopf = hopfProject(rot.x, rot.y, rot.z, rot.w);
        const stereo = stereographic(hopf.x, hopf.y, hopf.z);
        return {
          x: cx + stereo.x * scale,
          y: cy + stereo.y * scale,
          depth: hopf.z
        };
      });

      // Draw edges
      ctx.strokeStyle = 'rgba(148, 163, 184, 0.15)';
      ctx.lineWidth = 1;
      state.edges.forEach(([i, j]) => {
        ctx.beginPath();
        ctx.moveTo(projected[i].x, projected[i].y);
        ctx.lineTo(projected[j].x, projected[j].y);
        ctx.stroke();
      });

      // Draw entanglement links
      ctx.strokeStyle = 'rgba(244, 63, 94, 0.5)';
      ctx.setLineDash([4, 4]);
      state.qubits.forEach((q, i) => {
        q.entangled.forEach(j => {
          if (i < j) {
            ctx.beginPath();
            ctx.moveTo(projected[i].x, projected[i].y);
            ctx.lineTo(projected[j].x, projected[j].y);
            ctx.stroke();
          }
        });
      });
      ctx.setLineDash([]);

      // Draw qubits
      state.qubits.forEach((q, i) => {
        const p = projected[i];
        const { p0, p1 } = spinorProbs(q.state);

        // Color: Blue (|0⟩) to Red (|1⟩)
        const r = Math.round(p1 * 255);
        const b = Math.round(p0 * 255);
        const certainty = Math.abs(p0 - 0.5) * 2;
        const radius = 4 + certainty * 8;

        ctx.fillStyle = `rgb(${r}, 100, ${b})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Bloch vector direction
        const vx = Math.sin(q.bloch.theta) * Math.cos(q.bloch.phi);
        const vy = Math.sin(q.bloch.theta) * Math.sin(q.bloch.phi);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + vx * 12, p.y - vy * 12);
        ctx.stroke();

        // Index label
        ctx.fillStyle = '#ffffff';
        ctx.font = '8px monospace';
        ctx.fillText(i.toString(), p.x + radius + 2, p.y + 3);
      });

      // Title
      ctx.fillStyle = '#FACC15';
      ctx.font = 'bold 12px monospace';
      ctx.fillText('24-CELL HOPF PROJECTION', 10, 20);

      ctx.fillStyle = '#94a3b8';
      ctx.font = '10px monospace';
      ctx.fillText('Binary Tetrahedral Group (2T) ≅ SL(2,3)', 10, 35);
    }

    function renderMoire() {
      const canvas = document.getElementById('moireCanvas');
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;

      ctx.fillStyle = '#020617';
      ctx.fillRect(0, 0, W, H);

      const cx = W/2, cy = H/2;
      const radius = Math.min(W, H) * 0.4;

      // Get average orientation from first qubit
      const q = state.qubits[0];
      const phase = q.bloch.phi;

      // Reference grating (gold)
      ctx.strokeStyle = 'rgba(250, 204, 21, 0.4)';
      ctx.lineWidth = 1;
      const gridLines = 12;
      for (let i = 0; i < gridLines; i++) {
        const angle = (2 * Math.PI * i / gridLines);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
        ctx.stroke();
      }
      for (let i = 1; i <= 4; i++) {
        ctx.beginPath();
        ctx.arc(cx, cy, radius * i / 4, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Current grating (cyan) - shifted by phase
      ctx.strokeStyle = 'rgba(34, 211, 238, 0.4)';
      for (let i = 0; i < gridLines; i++) {
        const angle = (2 * Math.PI * i / gridLines) + phase;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
        ctx.stroke();
      }

      // Marker showing phase difference
      ctx.fillStyle = '#F43F5E';
      const markerR = radius * 0.6;
      ctx.beginPath();
      ctx.arc(cx + Math.cos(phase) * markerR, cy + Math.sin(phase) * markerR, 6, 0, Math.PI * 2);
      ctx.fill();

      // Phase label
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 11px monospace';
      ctx.textAlign = 'center';
      const deg = (phase * 180 / Math.PI).toFixed(1);
      ctx.fillText(`Δφ = ${deg}°`, cx, H - 10);
      ctx.textAlign = 'left';
    }

    function renderNomogram() {
      const canvas = document.getElementById('nomogramCanvas');
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;

      ctx.fillStyle = '#020617';
      ctx.fillRect(0, 0, W, H);

      const margin = 40;
      const scaleH = H - 2 * margin;
      const scaleXs = [margin + 20, W/2, W - margin - 20];

      // Scale labels
      const labels = ['TIME', 'VELOCITY', 'ENERGY'];
      const ranges = [[10, 1000], [0.1, 100], [0, 1]];

      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 2;

      scaleXs.forEach((sx, idx) => {
        // Draw scale line
        ctx.beginPath();
        ctx.moveTo(sx, margin);
        ctx.lineTo(sx, margin + scaleH);
        ctx.stroke();

        // Title
        ctx.fillStyle = '#94a3b8';
        ctx.font = 'bold 9px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(labels[idx], sx, margin - 10);

        // Tick marks
        ctx.font = '8px monospace';
        const ticks = 5;
        for (let i = 0; i <= ticks; i++) {
          const y = margin + (i / ticks) * scaleH;
          ctx.beginPath();
          ctx.moveTo(sx - 5, y);
          ctx.lineTo(sx + 5, y);
          ctx.stroke();
        }
      });

      // Current values based on state
      const timeVal = state.time * 10 + 10;
      const energyVal = state.energy;
      const velocityVal = timeVal > 0 ? energyVal * 100 / timeVal : 0;

      // Map to Y positions (log scale for time/velocity)
      const timeY = margin + (1 - Math.log10(timeVal) / 3) * scaleH;
      const energyY = margin + (1 - energyVal) * scaleH;
      const velY = margin + (1 - (velocityVal > 0 ? Math.log10(velocityVal + 0.1) / 2 : 0)) * scaleH;

      // Draw computation line
      ctx.strokeStyle = '#FACC15';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(scaleXs[0], timeY);
      ctx.lineTo(scaleXs[2], energyY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw markers
      ctx.fillStyle = '#F43F5E';
      ctx.beginPath();
      ctx.arc(scaleXs[0], timeY, 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#22D3EE';
      ctx.beginPath();
      ctx.arc(scaleXs[2], energyY, 5, 0, Math.PI * 2);
      ctx.fill();

      // Result marker
      ctx.fillStyle = '#FACC15';
      ctx.beginPath();
      ctx.arc(scaleXs[1], velY, 7, 0, Math.PI * 2);
      ctx.fill();

      ctx.textAlign = 'left';
    }

    function renderQubitGrid() {
      const grid = document.getElementById('qubitGrid');
      grid.innerHTML = '';

      state.qubits.forEach((q, i) => {
        const { p0, p1 } = spinorProbs(q.state);
        const r = Math.round(p1 * 255);
        const b = Math.round(p0 * 255);

        const cell = document.createElement('div');
        cell.className = 'qubit-cell';
        cell.style.background = `rgb(${r}, 100, ${b})`;
        cell.style.color = (p0 > 0.7 || p1 > 0.7) ? '#ffffff' : '#000000';
        cell.textContent = i;
        cell.onclick = () => { selectedQubit = i; };
        grid.appendChild(cell);
      });
    }

    function updateStats() {
      document.getElementById('statTime').textContent = state.time;
      document.getElementById('statEnergy').textContent = state.energy.toFixed(3);
      document.getElementById('statTemp').textContent = state.temperature.toFixed(3);

      const entangled = state.qubits.reduce((sum, q) => sum + q.entangled.length, 0) / 2;
      document.getElementById('statEntangled').textContent = entangled;
    }

    function log(message, type = 'info') {
      const logEl = document.getElementById('eventLog');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      const time = new Date().toLocaleTimeString();
      entry.textContent = `[${time}] ${message}`;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // ANIMATION LOOP
    // ═══════════════════════════════════════════════════════════════════════════
    function animate() {
      renderMain();
      requestAnimationFrame(animate);
    }

    // Initialize
    initState();
    render();
    animate();
  </script>
</body>
</html>
