# Theory of Operation: Rational Dynamics Engine
**Architecture Deep Dive**

## 1. System Overview
The KineticLens engine operates on a "Triletic" philosophy: validating motion through three independent verification layers (Optical, Inertial, Structural). This document details how `services/imageCompositor.ts` and `services/geminiService.ts` implement this logic.

## 2. The Triletic Matrix Composite
Instead of sending a video stream (high bandwidth, low semantic density) to the Gemini API, the system constructs a single **Composite Analysis Frame**. This frame is a 3x3 grid (or 1x3 in Standard Mode) generated by `createTrileticComposite`.

### Layer 1: The Epipolar Field (Row 0)
*   **Source:** Wide-angle capture (1x).
*   **Overlay Logic:** `drawEpipolarGeometry` function.
*   **Computation:**
    1.  Calculates the **Focus of Expansion (FOE)** based on the accelerometer vector `(w/2 - acc.x*80, h/2 + acc.y*80)`.
    2.  Projects 12 radial rays from the FOE.
*   **AI Interpretation:** Objects moving *along* the rays are static (parallax only). Objects crossing *through* the rays have independent velocity.

### Layer 2: The Interferometer (Row 1)
*   **Source:** Telephoto capture (2x, software cropped or lens switched).
*   **Overlay Logic:** `drawHyperLatticeInterference` function.
*   **The Uncertainty Offset:**
    The code explicitly renders "Ghost" lines if the sensor jitter is high.
    ```typescript
    const offsetMagnitude = (jerk * interval) * 0.05;
    if (offsetMagnitude > 1.0) { renderGhostMesh(); }
    ```
*   **Significance:** This visually encodes the *confidence interval* into the image. If Gemini sees double gold lines, it triggers the `HIGH_MOIRE_VARIANCE` warning in its reasoning chain.

### Layer 3: The Velocity Rail (Bottom Panel)
*   **Source:** `CapturePoint` timestamp metadata.
*   **Overlay Logic:** `drawVelocityRail`.
*   **Computation:** Renders beads on a timeline where horizontal position = time `t` and bead radius = Kinetic Energy `||a||`.
*   **Color Coding:**
    *   **RED:** T0 (Start)
    *   **GREEN:** T1 (Mid)
    *   **BLUE:** T2 (End)

## 3. The Geometric Proof Protocol (`geminiService.ts`)
The `analyzeMotionSession` function does not ask the AI to "guess" the speed. It forces the AI to solve for $V$.

### 3.1 Prompt Engineering
The system prompt injects real-time telemetry variables:
*   `zShift`: Calculated from `last.acceleration.z - first.acceleration.z`. Determines if the motion is volumetric.
*   `avgEff`: The average Vector Efficiency.

### 3.2 The Quality Control Block
The compositor burns a specific legend into the bottom right of the image (`drawVisualKey` function). This contains the `VECTOR EFFICIENCY %`.
*   **Logic:** The System Instruction in `geminiService.ts` reads:
    > "Condition: UNSTABLE... Do NOT trust the Gold Lattice alignment."
    
    This conditional logic creates a **Branched Reasoning Path** for the LLM. It essentially switches the model's internal algorithm from "Inertial Dead Reckoning" (trust sensors) to "Optical Flow Estimation" (trust pixels) based on the burned-in text.

## 4. Rational Dynamics Polling (`CaptureScreen.tsx`)
In `MATRIX_BURST` mode, the system does not capture at fixed intervals. It uses an adaptive loop:

```typescript
const getRationalDelay = (zoom: number) => {
   const jerk = getMoireVariance();
   // Delay increases if the camera is shaking/jerking to allow stabilization
   const adaptive = Math.max(33, 200 * Math.exp(-0.5 * jerk * zoom));
   return adaptive;
};
```
This ensures that frames are captured during "micro-valleys" of stability, maximizing the sharpness of the source images before they reach the compositor.
